#include "utils.h"
#include "getAddress.h"
#include "os.h"
#include "ux.h"

static char address_str[FULL_ADDRESS_LENGTH];
static char public_key_str[FULL_PUBKEY_LENGTH];
static uint32_t accountNum;

static uint8_t set_result_get_address() {
    //Initialize index to 0
    uint8_t tx = 0;

    //Get the length of the address, strlen will work since it is base 58 encoded.
    const uint8_t address_size = FULL_ADDRESS_LENGTH;
    const uint8_t public_key_size = FULL_PUBKEY_LENGTH;

    //Copy address data to the output buffer
    os_memmove(G_io_apdu_buffer + tx, address_str, address_size);
    tx += address_size;

    //Copy Public Key data to output buffer
    os_memmove(G_io_apdu_buffer + tx, public_key_str, public_key_size);
    tx += public_key_size;

    return tx;
}

//////////////////////////////////////////////////////////////////////

UX_STEP_NOCB(
    ux_display_public_flow_5_step,
    bnnn_paging,
    {
      .title = "Address",
      .text = address_str,
    });
UX_STEP_VALID(
    ux_display_public_flow_6_step,
    pb,
    sendResponse(set_result_get_address(), true),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_VALID(
    ux_display_public_flow_7_step,
    pb,
    sendResponse(0, false),
    {
      &C_icon_crossmark,
      "Reject",
    });

UX_FLOW(ux_display_public_flow,
  &ux_display_public_flow_5_step,
  &ux_display_public_flow_6_step,
  &ux_display_public_flow_7_step
);

void parseGetAddressData(struct apduMessage *apdu)
{
    //Parse Account Number
    accountNum = readUint32BE(apdu->cData);
}

void handleGetAddress(struct apduMessage *apdu, volatile unsigned int *flags, volatile unsigned int *tx) {
    uint8_t publicKey[32] = {0};

    //Get Public key from ED25519 private key. This is done by creating a BIP32 path using the account number and deriving a key.
    getPublicKey(accountNum, publicKey);

    //Get Public Key string from binary
    btox(public_key_str, (const char*)publicKey, FULL_PUBKEY_LENGTH);

    //Address is generated by calculating SHA256 hash and base 58 encoding the result.
    getAddressStringFromBinary(publicKey, address_str);

    //Check parameter1 to determine if we need to skip confirmation from the user.
    if (apdu->p1 == P1_NON_CONFIRM)
    {
        //Set address to the output buffer.
        *tx = set_result_get_address();
        THROW(0x9000);
    }
    else
    {
        //Register UI steps for returning address to the user.
        ux_flow_init(0, ux_display_public_flow, NULL);

        //Set flags to indicate that user input is required to continue.
        *flags |= IO_ASYNCH_REPLY;
    }
}
